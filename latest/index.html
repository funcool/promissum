<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.2">
<meta name="author" content="Andrey Antukh, &lt;niwi@niwi.nz&gt;">
<title>promissum - composable promise/future library for Clojure</title>
<style>
.listingblock .pygments .hll { background-color: #ffffcc }
.listingblock .pygments  { background: #f0f0f0; }
.listingblock .pygments .tok-c { color: #60a0b0; font-style: italic } /* Comment */
.listingblock .pygments .tok-err { border: 1px solid #FF0000 } /* Error */
.listingblock .pygments .tok-k { color: #007020; font-weight: bold } /* Keyword */
.listingblock .pygments .tok-o { color: #666666 } /* Operator */
.listingblock .pygments .tok-cm { color: #60a0b0; font-style: italic } /* Comment.Multiline */
.listingblock .pygments .tok-cp { color: #007020 } /* Comment.Preproc */
.listingblock .pygments .tok-c1 { color: #60a0b0; font-style: italic } /* Comment.Single */
.listingblock .pygments .tok-cs { color: #60a0b0; background-color: #fff0f0 } /* Comment.Special */
.listingblock .pygments .tok-gd { color: #A00000 } /* Generic.Deleted */
.listingblock .pygments .tok-ge { font-style: italic } /* Generic.Emph */
.listingblock .pygments .tok-gr { color: #FF0000 } /* Generic.Error */
.listingblock .pygments .tok-gh { color: #000080; font-weight: bold } /* Generic.Heading */
.listingblock .pygments .tok-gi { color: #00A000 } /* Generic.Inserted */
.listingblock .pygments .tok-go { color: #888888 } /* Generic.Output */
.listingblock .pygments .tok-gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
.listingblock .pygments .tok-gs { font-weight: bold } /* Generic.Strong */
.listingblock .pygments .tok-gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.listingblock .pygments .tok-gt { color: #0044DD } /* Generic.Traceback */
.listingblock .pygments .tok-kc { color: #007020; font-weight: bold } /* Keyword.Constant */
.listingblock .pygments .tok-kd { color: #007020; font-weight: bold } /* Keyword.Declaration */
.listingblock .pygments .tok-kn { color: #007020; font-weight: bold } /* Keyword.Namespace */
.listingblock .pygments .tok-kp { color: #007020 } /* Keyword.Pseudo */
.listingblock .pygments .tok-kr { color: #007020; font-weight: bold } /* Keyword.Reserved */
.listingblock .pygments .tok-kt { color: #902000 } /* Keyword.Type */
.listingblock .pygments .tok-m { color: #40a070 } /* Literal.Number */
.listingblock .pygments .tok-s { color: #4070a0 } /* Literal.String */
.listingblock .pygments .tok-na { color: #4070a0 } /* Name.Attribute */
.listingblock .pygments .tok-nb { color: #007020 } /* Name.Builtin */
.listingblock .pygments .tok-nc { color: #0e84b5; font-weight: bold } /* Name.Class */
.listingblock .pygments .tok-no { color: #60add5 } /* Name.Constant */
.listingblock .pygments .tok-nd { color: #555555; font-weight: bold } /* Name.Decorator */
.listingblock .pygments .tok-ni { color: #d55537; font-weight: bold } /* Name.Entity */
.listingblock .pygments .tok-ne { color: #007020 } /* Name.Exception */
.listingblock .pygments .tok-nf { color: #06287e } /* Name.Function */
.listingblock .pygments .tok-nl { color: #002070; font-weight: bold } /* Name.Label */
.listingblock .pygments .tok-nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
.listingblock .pygments .tok-nt { color: #062873; font-weight: bold } /* Name.Tag */
.listingblock .pygments .tok-nv { color: #bb60d5 } /* Name.Variable */
.listingblock .pygments .tok-ow { color: #007020; font-weight: bold } /* Operator.Word */
.listingblock .pygments .tok-w { color: #bbbbbb } /* Text.Whitespace */
.listingblock .pygments .tok-mb { color: #40a070 } /* Literal.Number.Bin */
.listingblock .pygments .tok-mf { color: #40a070 } /* Literal.Number.Float */
.listingblock .pygments .tok-mh { color: #40a070 } /* Literal.Number.Hex */
.listingblock .pygments .tok-mi { color: #40a070 } /* Literal.Number.Integer */
.listingblock .pygments .tok-mo { color: #40a070 } /* Literal.Number.Oct */
.listingblock .pygments .tok-sb { color: #4070a0 } /* Literal.String.Backtick */
.listingblock .pygments .tok-sc { color: #4070a0 } /* Literal.String.Char */
.listingblock .pygments .tok-sd { color: #4070a0; font-style: italic } /* Literal.String.Doc */
.listingblock .pygments .tok-s2 { color: #4070a0 } /* Literal.String.Double */
.listingblock .pygments .tok-se { color: #4070a0; font-weight: bold } /* Literal.String.Escape */
.listingblock .pygments .tok-sh { color: #4070a0 } /* Literal.String.Heredoc */
.listingblock .pygments .tok-si { color: #70a0d0; font-style: italic } /* Literal.String.Interpol */
.listingblock .pygments .tok-sx { color: #c65d09 } /* Literal.String.Other */
.listingblock .pygments .tok-sr { color: #235388 } /* Literal.String.Regex */
.listingblock .pygments .tok-s1 { color: #4070a0 } /* Literal.String.Single */
.listingblock .pygments .tok-ss { color: #517918 } /* Literal.String.Symbol */
.listingblock .pygments .tok-bp { color: #007020 } /* Name.Builtin.Pseudo */
.listingblock .pygments .tok-vc { color: #bb60d5 } /* Name.Variable.Class */
.listingblock .pygments .tok-vg { color: #bb60d5 } /* Name.Variable.Global */
.listingblock .pygments .tok-vi { color: #bb60d5 } /* Name.Variable.Instance */
.listingblock .pygments .tok-il { color: #40a070 } /* Literal.Number.Integer.Long */
</style>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic|Liberation+Mono:400|Roboto+Slab:400,700"/>
<link rel="stylesheet" href="https://www.niwi.nz/_assets/asciidoctor-styles/simple-red-titles/stylesheet.css"/>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>promissum - composable promise/future library for Clojure</h1>
<div class="details">
<span id="author" class="author">Andrey Antukh, &lt;niwi@niwi.nz&gt;</span><br>
<span id="revdate">0.3.3</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#introduction">Introduction</a>
<ul class="sectlevel2">
<li><a href="#project-maturity">Project Maturity</a></li>
<li><a href="#install">Install</a></li>
</ul>
</li>
<li><a href="#user-guide">User Guide</a>
<ul class="sectlevel2">
<li><a href="#introduction-2">Introduction</a></li>
<li><a href="#creating-a-promise">Creating a promise</a></li>
<li><a href="#creating-a-future">Creating a future</a></li>
<li><a href="#blocking-operations">Blocking operations</a></li>
<li><a href="#state-checking">State checking</a></li>
<li><a href="#promise-chaining">Promise chaining</a></li>
<li><a href="#error-handling">Error handling</a></li>
<li><a href="#working-with-collections">Working with collections</a></li>
</ul>
</li>
<li><a href="#developers-guide">Developers Guide</a>
<ul class="sectlevel2">
<li><a href="#contribute">Contribute</a></li>
</ul>
</li>
<li><a href="#get-the-code">Get the Code</a>
<ul class="sectlevel2">
<li><a href="#run-tests">Run tests</a></li>
<li><a href="#license">License</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="introduction"><a class="link" href="#introduction">Introduction</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>A lightweight promise/future abstraction built on top of JDK8 <code>CompletableFuture</code>.</p>
</div>
<div class="sect2">
<h3 id="project-maturity"><a class="link" href="#project-maturity">Project Maturity</a></h3>
<div class="paragraph">
<p>Since <em>promissum</em> is a young project there may be some API breakage.</p>
</div>
</div>
<div class="sect2">
<h3 id="install"><a class="link" href="#install">Install</a></h3>
<div class="paragraph">
<p>The simplest way to use <em>promissum</em> library in a Clojure project is by including
it as a dependency:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">[</span><span class="tok-nv">funcool/promissum</span> <span class="tok-s">&quot;0.3.3&quot;</span><span class="tok-p">]</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="user-guide"><a class="link" href="#user-guide">User Guide</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="introduction-2"><a class="link" href="#introduction-2">Introduction</a></h3>
<div class="paragraph">
<p>The promise consists in a container that eventually will contain a value with
builtin support for error handling. So the promise has three different states:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>resolved</code>: means that the promise contains a value.</p>
</li>
<li>
<p><code>rejected</code>: means thet the promise contains an error.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In summary: is the abstraction that represents the result of an asynchronous
operation that will be eventually available.</p>
</div>
<div class="paragraph">
<p>The <em>promissum</em>'s promise abstraction just works on top of the awesome
<code>CompletableFuture</code> future/promise implementation available in JDK8. And offers
a very lightweight layer on top of it.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Clojure comes with a builtin promise abstraction but it is designed only for
blocking operations, and in async environments the blocking operations are
completely discouraged.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="creating-a-promise"><a class="link" href="#creating-a-promise">Creating a promise</a></h3>
<div class="paragraph">
<p>It there several different ways to create a promise in <em>promissum</em> library. You can
create it already resolved with initial value or already rejected with an exception.</p>
</div>
<div class="paragraph">
<p>Let start with a basic example using the commonly known promise delivering in
clojure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">promissum.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">p</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nb">pr </span><span class="tok-p">(</span><span class="tok-nf">p/promise</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">future</span>
  <span class="tok-p">(</span><span class="tok-nf">Thread/sleep</span> <span class="tok-mi">200</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">p/deliver</span> <span class="tok-nb">pr </span><span class="tok-mi">20</span><span class="tok-p">))]</span>

<span class="tok-p">(</span><span class="tok-nf">p/then</span> <span class="tok-nb">pr </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">v</span><span class="tok-p">]</span>
             <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-nv">v</span><span class="tok-p">)))</span>

<span class="tok-c1">;; After 200ms it will print `20`</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An other way to create a promise is using a factory function that can resolve or
reject promise in asynchronous way. If you are familiar with javascript promises,
you will found that very familiar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nb">pr </span><span class="tok-p">(</span><span class="tok-nf">p/promise</span>
          <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">deliver</span><span class="tok-p">]</span>
            <span class="tok-p">(</span><span class="tok-nf">deliver</span> <span class="tok-mi">1</span><span class="tok-p">))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>promissum</em> also exposes a clojure&#8217;s <code>future</code> alternative that works in the same
way with the difference that it returns a <code>CompletableFuture</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nb">pr </span><span class="tok-p">(</span><span class="tok-nf">p/future</span>
          <span class="tok-p">(</span><span class="tok-nf">Thread/sleep</span> <span class="tok-mi">200</span><span class="tok-p">)</span>
          <span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-o">@</span><span class="tok-nv">pr</span>
<span class="tok-c1">;; =&gt; 2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You should know that <code>promise</code> and <code>future</code> functions just return
a <code>CompletableFuture</code> instance without additional wrapping.</p>
</div>
</div>
<div class="sect2">
<h3 id="creating-a-future"><a class="link" href="#creating-a-future">Creating a future</a></h3>
<div class="paragraph">
<p>The <em>promissum</em> library also exposes a convenient macro for clojure <code>future</code> macro
replacement. It works in exactly manner that the clojure version, with a little
difference that it returns a composable promise that can be easily chained in an
asynchronous way.</p>
</div>
<div class="paragraph">
<p>See an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">deref </span><span class="tok-p">(</span><span class="tok-nf">p/future</span>
         <span class="tok-p">(</span><span class="tok-nf">Thread/sleep</span> <span class="tok-mi">200</span><span class="tok-p">)</span>
         <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">)))</span>
<span class="tok-c1">;; =&gt; 3</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="blocking-operations"><a class="link" href="#blocking-operations">Blocking operations</a></h3>
<div class="paragraph">
<p>The <em>promissum</em>'s promises can be used as drop in replacement for clojure promises,
because them offers also blocking operations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-o">@</span><span class="tok-nv">pr</span>
<span class="tok-c1">;; =&gt; 1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you try to deref a promise that is rejected, the exception will be rereaised in
the calling thread. You should take care that the reraised exception is wrapped in
<code>ExecutionException</code> in the same way as builtin clojure promise/future does.</p>
</div>
<div class="paragraph">
<p>For avouid unnecesary pain constantly handling that, <em>promissum</em> exposes the
<code>await</code> function. It has the same call signature as clojure builtin deref function
but if promise contains a exception that exception will be reraised as is (without
additional wrapping).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">p/await</span> <span class="tok-nv">pr</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 1</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="state-checking"><a class="link" href="#state-checking">State checking</a></h3>
<div class="paragraph">
<p><em>promissum</em> provides useful predicates that will allow check the state of a promise
in any time.</p>
</div>
<div class="paragraph">
<p>Let see some examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nb">pr </span><span class="tok-p">(</span><span class="tok-nf">p/promise</span> <span class="tok-mi">2</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">p/promise?</span> <span class="tok-nv">pr</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">p/pending?</span> <span class="tok-nv">pr</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span>

<span class="tok-p">(</span><span class="tok-nf">p/resolved?</span> <span class="tok-nv">pr</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">p/rejected?</span> <span class="tok-nv">pr</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span>

<span class="tok-p">(</span><span class="tok-nf">p/done?</span> <span class="tok-nv">pr</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>done?</code> predicate checks if a promise is fullfiled, independently if is resolved
or rejected.</p>
</div>
</div>
<div class="sect2">
<h3 id="promise-chaining"><a class="link" href="#promise-chaining">Promise chaining</a></h3>
<div class="paragraph">
<p>It there different ways to compose/chain computations using promises. We will start
with the basic: lineal way of chaining computations.</p>
</div>
<div class="paragraph">
<p>That can be done using <code>then</code> or <code>chain</code> functions exposed in <code>promissum.core</code>
namespace. Bot them are mainly interchangeable. The main differencia is that
<code>chain</code> is variadic and <code>then</code> not.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nb">pr </span><span class="tok-p">(</span><span class="tok-nb">-&gt; </span><span class="tok-p">(</span><span class="tok-nf">p/promise</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
            <span class="tok-p">(</span><span class="tok-nf">p/then</span> <span class="tok-nv">inc</span><span class="tok-p">)</span>
            <span class="tok-p">(</span><span class="tok-nf">p/then</span> <span class="tok-nv">inc</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">p/await</span> <span class="tok-nv">pr</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 4</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And here the same example using the <code>chain</code> function instead of <code>then</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nb">pr </span><span class="tok-p">(</span><span class="tok-nf">p/chain</span> <span class="tok-p">(</span><span class="tok-nf">p/promise</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-nb">inc </span><span class="tok-nv">inc</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-nf">p/await</span> <span class="tok-nv">pr</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 4</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Later, thanks to the <a href="https://github.com/funcool/cats">cats</a> library, it there
other few methods of create promise compositions in more powerfull way: <code>mlet</code>
and <code>alet</code> macros.</p>
</div>
<div class="paragraph">
<p>For demostration purposes, imagine that you have this function that emulates async
operation and return a promise:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">promissum.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">p</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">sleep-promise</span>
  <span class="tok-p">[</span><span class="tok-nv">wait</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">p/promise</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">deliver</span><span class="tok-p">]</span>
               <span class="tok-p">(</span><span class="tok-nf">Thread/sleep</span> <span class="tok-nv">wait</span><span class="tok-p">)</span>
               <span class="tok-p">(</span><span class="tok-nf">deliver</span> <span class="tok-nv">wait</span><span class="tok-p">))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, we will try to use this function together with <code>mlet</code> macro and additionally
messure the execution time:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">time</span>
 <span class="tok-p">(</span><span class="tok-nf">p/await</span> <span class="tok-p">(</span><span class="tok-nf">m/mlet</span> <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nf">sleep-promise</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
                   <span class="tok-nv">y</span> <span class="tok-p">(</span><span class="tok-nf">sleep-promise</span> <span class="tok-mi">41</span><span class="tok-p">)]</span>
             <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">)))))</span>
<span class="tok-c1">;; &quot;Elapsed time: 84.328182 msecs&quot;</span>
<span class="tok-c1">;; =&gt; 83</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>mlet</code> bindings are executed sequentially, waiting in each step for promise
resolution. If an error occurs in some step, the entire composition will be
short-circuited, returing exceptionally resolved promise.</p>
</div>
<div class="paragraph">
<p>The main disadvantage of <code>mlet</code> is that it&#8217;s evaluation model is strictly
secuential. It is ok for some use cases, when the sequential order is mandatory.
But, if the strictly secuential model is not mandatory, <code>mlet</code> does not take
the advantage of concurrency.</p>
</div>
<div class="paragraph">
<p>For solve this problem, it there <code>alet</code> macro. It is almost identical to <code>mlet</code>
from the user experience, but internally it is based in very different abstractions.</p>
</div>
<div class="paragraph">
<p>Now, we will try to do the same example but using the <code>alet</code> macro:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">time</span>
 <span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-nf">m/alet</span> <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nf">sleep-promise</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
           <span class="tok-nv">y</span> <span class="tok-p">(</span><span class="tok-nf">sleep-promise</span> <span class="tok-mi">41</span><span class="tok-p">)]</span>
    <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">)))</span>
<span class="tok-c1">;; &quot;Elapsed time: 44.246427 msecs&quot;</span>
<span class="tok-c1">;; =&gt; 83</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We can observe that the return value is identical to the previous example,
but it takes almost half of time to finish execute all the computations. This
is happens because <code>alet</code> is more smarter macro and calculates de dependencies
between declared bindings and executes them in batches; taking fully advantage
of having fully miltithreaded/concurrent environment as is JVM.</p>
</div>
<div class="paragraph">
<p>You can read more about that <a href="http://funcool.github.io/cats/latest/#syntax-sugar">here</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="error-handling"><a class="link" href="#error-handling">Error handling</a></h3>
<div class="paragraph">
<p>One of the advantages of using promise abstraction is that it natively has
a notion of error, so you don&#8217;t need reinvent it. If some of the computations
of the composed promise chain/pipeline raises an exception, that one is
automatically propagated to the last promise making the effect of short-circuiting.</p>
</div>
<div class="paragraph">
<p>Let see an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nb">pr </span><span class="tok-p">(</span><span class="tok-nf">p/chain</span> <span class="tok-p">(</span><span class="tok-nf">p/promise</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
                 <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">v</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">throw</span> <span class="tok-p">(</span><span class="tok-nf">ex-info</span> <span class="tok-s">&quot;test&quot;</span> <span class="tok-p">{})))))</span>
<span class="tok-p">(</span><span class="tok-nf">p/await</span> <span class="tok-nv">pr</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; clojure.lang.ExceptionInfo &quot;test&quot; ...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For exception catching facilities, <em>promissum</em> exposes a <code>catch</code> function. It just
works like <code>then</code> but with exceptions. It attaches a next computation that only
will be executend if a previous computation resolves exceptionally:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nb">pr </span><span class="tok-p">(</span><span class="tok-nb">-&gt; </span><span class="tok-p">(</span><span class="tok-nf">p/promise</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
            <span class="tok-p">(</span><span class="tok-nf">p/then</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">v</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">throw</span> <span class="tok-p">(</span><span class="tok-nf">ex-info</span> <span class="tok-s">&quot;foobar&quot;</span> <span class="tok-p">{}))))</span>
            <span class="tok-p">(</span><span class="tok-nf">p/catch</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">error</span><span class="tok-p">]</span> <span class="tok-ss">:nothing</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">p/await</span> <span class="tok-nv">pr</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; :nothing</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>catch</code> chain function also return a promise, that will be resolved or rejected
depending on that will happen inside the catch handler.</p>
</div>
</div>
<div class="sect2">
<h3 id="working-with-collections"><a class="link" href="#working-with-collections">Working with collections</a></h3>
<div class="paragraph">
<p>In some circumstances you will want wait a completion of few promises at same time,
and <em>promissum</em> also provides helpers for that.</p>
</div>
<div class="paragraph">
<p>Imagine that you have a collection of promises and you want to wait until
all of them are resolved. This can be done using the <code>all</code> combinator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nb">pr </span><span class="tok-p">(</span><span class="tok-nf">p/all</span> <span class="tok-p">[(</span><span class="tok-nf">p/promise</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
                <span class="tok-p">(</span><span class="tok-nf">p/promise</span> <span class="tok-mi">2</span><span class="tok-p">)]))</span>
<span class="tok-p">(</span><span class="tok-nf">p/await</span> <span class="tok-nv">pr</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [1 2]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It there are also circumstances where you only want arbitrary select of the
first resolved promise. For this case, you can use the <code>any</code> combinator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nb">pr </span><span class="tok-p">(</span><span class="tok-nf">p/any</span> <span class="tok-p">[(</span><span class="tok-nf">p/promise</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
                <span class="tok-p">(</span><span class="tok-nf">p/promise</span> <span class="tok-p">(</span><span class="tok-nf">ex-info</span> <span class="tok-s">&quot;error&quot;</span> <span class="tok-p">{}))]))</span>
<span class="tok-p">(</span><span class="tok-nf">p/await</span> <span class="tok-nv">pr</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Later, for more advanced use cases, <em>promissum</em> is an algebraic structure that
implements the associative binary operation usually called <code>mappend</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nb">pr </span><span class="tok-p">(</span><span class="tok-nf">m/mappend</span> <span class="tok-p">(</span><span class="tok-nf">p/promise</span> <span class="tok-p">{</span><span class="tok-ss">:a</span> <span class="tok-mi">1</span><span class="tok-p">})</span>
                   <span class="tok-p">(</span><span class="tok-nf">p/promise</span> <span class="tok-p">{</span><span class="tok-ss">:b</span> <span class="tok-mi">2</span><span class="tok-p">})))</span>
<span class="tok-p">(</span><span class="tok-nf">p/await</span> <span class="tok-nv">pr</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; {:a 1 :b 2}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are interested in knowing more about it, plase refer to the
<a href="https://github.com/funcool/cats">cats documentation</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="developers-guide"><a class="link" href="#developers-guide">Developers Guide</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="contribute"><a class="link" href="#contribute">Contribute</a></h3>
<div class="paragraph">
<p>Unlike Clojure and other Clojure contrib libs, does not have many restrictions for
contributions. Just open a issue or pull request.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="get-the-code"><a class="link" href="#get-the-code">Get the Code</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>promissum</em> is open source and can be found on
<a href="https://github.com/funcool/promissum">github</a>.</p>
</div>
<div class="paragraph">
<p>You can clone the public repository with this command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text">git clone https://github.com/funcool/promissum</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="run-tests"><a class="link" href="#run-tests">Run tests</a></h3>
<div class="paragraph">
<p>For run tests just execute this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text">lein test</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="license"><a class="link" href="#license">License</a></h3>
<div class="paragraph">
<p><em>promissum</em> is licensed under BSD (2-Clause) license:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Copyright (c) 2015 Andrey Antukh &lt;niwi@niwi.nz&gt;

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2015-11-04 08:06:07 EET
</div>
</div>
</body>
</html>